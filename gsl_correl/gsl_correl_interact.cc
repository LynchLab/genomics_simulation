#include "interface.h"
#include "map_file.h"
#include "state.h"
#include "sample_name.h"
#include "correl_data.h"

#include <cstring>
#include <sstream>
#include <tuple>
#include <map>
#include <fstream>
#include <ctime>
#include <omp.h>

#include "Eigen/Core"

#define UINT uint32_t
#define WORD 32

#define BLOCK 10

#define t(a)	a.transpose()
#define Av(a,b) Eigen::VectorXf(a.array() * b.array() )
#define Am(a,b) Eigen::MatrixXf( a.array() * b.array() )
#define center(a,b) Eigen::MatrixXf( a.colwise() - b )

static UINT Mask[WORD]={0x00000001, 0x00000002, 0x00000004, 0x00000008,
			0x00000010, 0x00000020, 0x00000040, 0x00000080,
			0x00000100, 0x00000200, 0x00000400, 0x00000800,
			0x00001000, 0x00002000, 0x00004000, 0x00008000,
			0x00010000, 0x00020000, 0x00040000, 0x00080000,
			0x00100000, 0x00200000, 0x00400000, 0x00800000,
			0x01000000, 0x02000000, 0x04000000, 0x08000000,
			0x10000000, 0x20000000, 0x40000000, 0x80000000};

int calc(const float *a_vals, const float *b_vals, float *q_vals, const int32_t &B, const int32_t &N){

uint32_t a1_dimension=B;
uint32_t a2_dimension=N;

uint32_t b1_dimension=B;
uint32_t b2_dimension=N;

double *ir_vals=new double[B*B*N];
double *ic_vals=new double[B*B*N];
double  *i_vals=new double[B*B*N];

int32_t ir1_dimension=B;
int32_t ir2_dimension=B;
int32_t ir3_dimension=N;
int32_t ic1_dimension=B;
int32_t ic2_dimension=B;
int32_t ic3_dimension=N;
int32_t i1_dimension=B;
int32_t i2_dimension=B;
int32_t i3_dimension=N;
int32_t q1_dimension=N;
int32_t q2_dimension=N;

// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
for (int32_t ka = 0; ka < a1_dimension; ka++) {
  for (int32_t lb = 0; lb < b1_dimension; lb++) {
    int32_t pir2 = ka * ir2_dimension + lb;
    for (int32_t ia = 0; ia < a2_dimension; ia++) {
      int32_t pa2 = ka * a2_dimension + ia;
      int32_t pb2 = lb * b2_dimension + ia;
      int32_t pir3 = pir2 * ir3_dimension + ia;
      ir_vals[pir3] = a_vals[pa2] * b_vals[pb2];
    }
  }
}
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)

for (int32_t kir = 0; kir < ir1_dimension; kir++) {
  double tk = 1./N;
  for (int32_t lir = 0; lir < ir2_dimension; lir++) {
    int32_t pir2 = kir * ir2_dimension + lir;
    int32_t pic2 = kir * ic2_dimension + lir;
    double tj = 0;
    for (int32_t jir = 0; jir < ir3_dimension; jir++) {
      int32_t pir3 = pir2 * ir3_dimension + jir;
      tj += ir_vals[pir3];
    }
    ic_vals[pic2] = tj * tk;
  }
}
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
for (int32_t kir = 0; kir < ir1_dimension; kir++) {
  for (int32_t lir = 0; lir < ir2_dimension; lir++) {
    int32_t pir2 = kir * ir2_dimension + lir;
    int32_t pic2 = kir * ic2_dimension + lir;
    int32_t pi2 = kir * i2_dimension + lir;
    double tl = ic_vals[pic2];
    for (int32_t iir = 0; iir < ir3_dimension; iir++) {
      int32_t pir3 = pir2 * ir3_dimension + iir;
      int32_t pi3 = pi2 * i3_dimension + iir;
      i_vals[pi3] = ir_vals[pir3] - tl;
    }
  }
}
// Generated by the Tensor Algebra Compiler (tensor-compiler.org)
for (int32_t pq = 0; pq < q1_dimension * q2_dimension; pq++) {
  q_vals[pq] = 0;
}
for (int32_t ki = 0; ki < i1_dimension; ki++) {
  for (int32_t li = 0; li < i2_dimension; li++) {
    int32_t pi2 = ki * i2_dimension + li;
    int32_t pi20 = ki * i2_dimension + li;
    for (int32_t ii = 0; ii < i3_dimension; ii++) {
      int32_t pi3 = pi2 * i3_dimension + ii;
      double ti = i_vals[pi3];
      for (int32_t ji = 0; ji < i3_dimension; ji++) {
        int32_t pi30 = pi20 * i3_dimension + ji;
        int32_t pq2 = ii * q2_dimension + ji;
        q_vals[pq2] = q_vals[pq2] + ti * i_vals[pi30];
      }
    }
  }
}

delete [] ir_vals;
delete [] ic_vals;
delete [] i_vals;

return 0;
}

inline void transposed_bit_sumN(const UINT *place, const UINT &N, UINT *sum)
{
	const UINT *end=place+N;
	const UINT *this_place=place;
	while (this_place!=end) {
		sum[0]+=( (*this_place & Mask[0])!=0 );
		sum[1]+=( (*this_place & Mask[1])!=0 );
		sum[2]+=( (*this_place & Mask[2])!=0 );
		sum[3]+=( (*this_place & Mask[3])!=0 );
		sum[4]+=( (*this_place & Mask[4])!=0 );
		sum[5]+=( (*this_place & Mask[5])!=0 );
		sum[6]+=( (*this_place & Mask[6])!=0 );
		sum[7]+=( (*this_place & Mask[7])!=0 );
		sum[8]+=( (*this_place & Mask[8])!=0 );
		sum[9]+=( (*this_place & Mask[9])!=0 );
		sum[10]+=( (*this_place & Mask[10])!=0 );
		sum[11]+=( (*this_place & Mask[11])!=0 );
		sum[12]+=( (*this_place & Mask[12])!=0 );
		sum[13]+=( (*this_place & Mask[13])!=0 );
		sum[14]+=( (*this_place & Mask[14])!=0 );
		sum[15]+=( (*this_place & Mask[15])!=0 );
		sum[16]+=( (*this_place & Mask[16])!=0 );
		sum[17]+=( (*this_place & Mask[17])!=0 );
		sum[18]+=( (*this_place & Mask[18])!=0 );
		sum[19]+=( (*this_place & Mask[19])!=0 );
		sum[20]+=( (*this_place & Mask[20])!=0 );
		sum[21]+=( (*this_place & Mask[21])!=0 );
		sum[22]+=( (*this_place & Mask[22])!=0 );
		sum[23]+=( (*this_place & Mask[23])!=0 );
		sum[24]+=( (*this_place & Mask[24])!=0 );
		sum[25]+=( (*this_place & Mask[25])!=0 );
		sum[26]+=( (*this_place & Mask[26])!=0 );
		sum[27]+=( (*this_place & Mask[27])!=0 );
		sum[28]+=( (*this_place & Mask[28])!=0 );
		sum[29]+=( (*this_place & Mask[29])!=0 );
		sum[30]+=( (*this_place & Mask[30])!=0 );
		sum[31]+=( (*this_place & Mask[31])!=0 );
		this_place++;
	}
}

inline void transposed_het_sumN(const UINT *place, const UINT &N, UINT *sum)
{
	const UINT *end=place+2*N;
	const UINT *this_place1=place;
	const UINT *this_place2=place+N;
	while (this_place2!=end) {
		for (int x=0; x<WORD; ++x)
		{
			sum[x]+=( (*this_place1 & Mask[x])!=(*(this_place2) & Mask[x]) );
		}
		this_place1++;
		this_place2++;
	}
}

int main (int argc, char **argv){

	std::cerr << __FILE__ << std::endl;

	std::string names_file="", input_file="";
	int indX=-1, indY=-1, model=0;
	std::string namex="", namey="";

	Environment env;


	env.set_name("call_relatedness");
	env.set_version(VERSION);
	env.set_author("Matthew Ackerman");
	env.set_description("A POS relatedness caller. Please direct questions to matthew.s.ackerman@gmail.com");

	env.optional_arg('x',"namey",  namex,      "please provide a number.", "number of individuals in the populations.");
	env.optional_arg('y',"namex",  namey,      "please provide a number.", "number of individuals in the populations.");
	env.optional_arg('m',"model",  model,      "please provide a number.", "model of the DoGE to use.");
	env.optional_arg('i',"input",  input_file,      "please provide a number.", "number of individuals in the populations.");
	env.positional_arg('n',"names",  names_file,      "please provide a number.", "number of individuals in the populations.");

	if ( parsargs(argc, argv, env) != 0 ) print_usage(env);


	// random pair (X,Y) of integers on (0,L), (X,L)
	// sort by X

	//Eigen::initParallel();
	Eigen::setNbThreads(4);
	std::cerr << "using " << Eigen::nbThreads( ) << " threads.\n";

	State Pstates;
 	{
		Flat_file <State> state_file;
		if (input_file=="")
		{
			state_file.open(READ);
		}
		else
		{
			state_file.open(input_file.c_str(), READ);
		}
		Pstates=state_file.read_header();
		state_file.read(Pstates);
		state_file.close();
		std::cerr << "Sample: " << Pstates.sample_size() << ", " << " genome: "<<  Pstates.genome_size() << std::endl;
	}

	int N(Pstates.sample_size());
	int LEN(Pstates.genome_size()*32);
	
	Eigen::VectorXf s1=Eigen::ArrayXf::Zero(N);
	Eigen::VectorXf s2=Eigen::ArrayXf::Zero(N);
	Eigen::VectorXf s3=Eigen::ArrayXf::Zero(N);

	Eigen::VectorXf fs(N);
	Eigen::VectorXf dm(N);

	Eigen::MatrixXf S4=Eigen::ArrayXXf::Zero(N, N);
	Eigen::MatrixXf S5=Eigen::ArrayXXf::Zero(N, N);
	Eigen::MatrixXf S6=Eigen::ArrayXXf::Zero(N, N);

	UINT p_arr[WORD];
	UINT h_arr[WORD];

	std::default_random_engine rng;
	std::uniform_int_distribution<int> unif_L(0,LEN);

	size_t ll=0;

	UINT *P=new uint32_t [N*2];
	UINT *P2=P+N;

	Eigen::MatrixXf M1(BLOCK,N), H1(BLOCK,N);
	Eigen::MatrixXf M2(BLOCK,N), H2(BLOCK,N);

	Eigen::VectorXf Tc(BLOCK);
	Eigen::VectorXf Gc(BLOCK);
	Eigen::VectorXf Dc(BLOCK);

	Eigen::VectorXf S1(BLOCK); //Sorted random vectors with BLOCK elements on [1, l]
	Eigen::VectorXf S2(BLOCK); // 	" 	"

	Eigen::MatrixXf T(N,N);
	Eigen::MatrixXf G(N,N);
	Eigen::MatrixXf D(N,N);

	clock_t t1, t2, t3, s;
	size_t K1=0, K2=0;

	for (size_t i=0; i<5000; i++) 
	{
		std::cerr << "randomizing.\n";

		for (size_t x=0; x<BLOCK; x++)
		{
			S1[x] = unif_L(rng);
			S2[x] = unif_L(rng);
		}

		std::sort(S1.data(), S1.data()+S1.size());
		std::sort(S2.data(), S2.data()+S2.size());

		std::cerr << Pstates.genome_size() << std::endl;

		std::cerr << "reading.\n";

		Pstates.rewind();

		while (!Pstates.empty())
		{
			Pstates.uncompress(P, P2);
			//TODO I think these can be dropped by moving them into Eigen...
			memset(p_arr, 0, sizeof(UINT)*WORD);
	
			//CHECK TO SEE IF WE NEED IT
			transposed_bit_sumN(P, 2*N, p_arr);
			for (size_t k=0; k<WORD; k++)
			{
				double p=double(p_arr[k])/double(2*N);
				{
					if (K1<BLOCK){
					//	std::cerr << S1[K1] << " S1[K1] " << std::endl;
						while ( ll == S1[K1] )
						{
							for ( size_t x = 0; x < N; x++)
							{							
								M1(K1,x) = ( (P[x] & (1<<k) ) !=0)+( (P2[x] & (1 << k) ) !=0);
								H1(K1,x) = ( (P[x] & (1 << k) )!=(P2[x] & (1<<k) ) );
							}
							K1++;
							//std::cerr << ll << ", " << K1 << ", " << K2 << std::endl;
							if (K1==BLOCK) break;
						}
					}
					if (K2<BLOCK) {
					//	std::cerr << S2[K2] << " S2[K2] " << std::endl;
						while ( ll == S2[K2] )
						{
							for ( size_t x = 0; x<N; x++)
							{
							
								M2(K2,x) = ( (P[x] & (1<<k) ) !=0)+( (P2[x] & (1 << k) ) !=0);
								H2(K2,x) = ( (P[x] & (1 << k) )!=(P2[x] & (1<<k) ) );
							}
							K2++;
							//std::cerr << ll << ", " << K1 << ", " << K2 << std::endl;
							if (K2==BLOCK) break;
						}
					} 
				}
				ll++;
			}
			if ( K1 == BLOCK && K2 == BLOCK ) break;
		}

		std::cerr << "randomizing 2.\n";

		for ( size_t k = BLOCK-1; k > 0; k-- )
		{
			std::uniform_int_distribution<int> unif_B(0,k);
			size_t i=unif_B(rng);
			size_t j=unif_B(rng);
			M2.row(i).swap( M2.row(k) );
			H2.row(j).swap( H2.row(k) );
		}

		std::cerr << "multiplying.\n";

		{
			
			calc(M1.data(), M2.data(), T.data(), BLOCK, N);
			calc(M1.data(), H2.data(), G.data(), BLOCK, N);
			calc(H1.data(), H2.data(), D.data(), BLOCK, N);

			S4+=T;
			S5+=G;
			S6+=D;

			calc(M2.data(), M1.data(), T.data(), BLOCK, N);
			calc(M2.data(), H1.data(), G.data(), BLOCK, N);
			calc(H2.data(), H1.data(), D.data(), BLOCK, N);

			S4+=T;
			S5+=G;
			S6+=D;

			s1+=T.colwise().sum();
			s2+=G.colwise().sum();
			s3+=D.colwise().sum();
		}
	}

	double S4T = S4.trace()/double(N);
	double S5T = S5.trace()/double(N);
	double S6T = S6.trace()/double(N);

	ll=BLOCK;

	S4/=abs(S4T) * ll / ( (ll-1) );
	S5/=abs(S5T) * ll / ( (ll-1) );
	S6/=abs(S6T) * ll / ( (ll-1) );

	s1 = s1/sqrt(S4T)/sqrt(2*(ll-1) );
	s2 = s2/sqrt(S5T)/sqrt(2*(ll-1) );
	s3 = s2/sqrt(S6T)/sqrt(2*(ll-1) );

	char del = '\t';	
	for ( size_t x = 0; x < N; x++ )
	{
		std::cout << s1(x) << del;
		std::cout << s2(x) << del;
		std::cout << s3(x) << del;
		for ( size_t y = 0; y<N; y++)
		{
			std::cout << S4(x,y) << del;
		}
		for ( size_t y = 0; y<N; y++)
		{
			std::cout << S5(x,y) << del;
		}
		for ( size_t y = 0; y<N-1; y++)
		{
			std::cout << S6(x,y) << del;
		}
		std::cout << S6(x,N-1) << std::endl;
	}
}
